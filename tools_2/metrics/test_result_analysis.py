#!/usr/bin/env python
# encoding:utf-8
"""
@author: sunchongjing
@license: (C) Copyright 2019, Union Big Data Co. Ltd. All rights reserved.
@contact: sunchongjing@unionbigdata.com
@software:
@file: test_result_analysis.py
@time: 2019/9/6 16:23
@desc:
"""
import pickle
import json
import os
import cv2
from sklearn.metrics import confusion_matrix
import pandas as pd

ok_code = 'False'
others_code = 'Others'


class ResultAnalysis(object):

    def __init__(self, img_root, test_json_path, test_pkl_path, merge, merge_dict):
        """

        :param img_root: the root path for saving the image and xml files
        :param test_json_path: the coco dataset json for testing
        :param test_pkl_path: the pkl generated by testing
        """
        self.img_root = img_root
        self.test_json_file = test_json_path
        self.test_pkl_file = test_pkl_path
        # opzealot
        self.merge = merge
        self.merge_dict = merge_dict
        # get the model categories from json file
        with open(self.test_json_file, 'r', encoding='utf-8') as f:
            load_dict = json.load(f)
        categories = load_dict['categories']
        id_name_list = []
        for category_info in categories:
            id_name_list.append((int(category_info['id']), category_info['name']))
        result = sorted(id_name_list, key=lambda x: x[0])
        self.model_categories = [x[1] for x in result]
        if ok_code not in self.model_categories:
            self.model_categories.append(ok_code)

        if others_code not in self.model_categories:
            self.model_categories.append(others_code)

    def get_test_img_relative_paths(self):
        """
        get the image name(with relative path) list from json file
        :return:
        """

        with open(self.test_json_file, 'r', encoding='utf-8') as f:
            load_dict = json.load(f)
        images = load_dict['images']
        images_names_with_relative_path = []
        for image in images:
            image_name = image['file_name']
            images_names_with_relative_path.append(image_name)
        return images_names_with_relative_path

    def get_true_img_category(self):
        """
         get the true category for each image, by extracting category name from file path
        :return:
        """
        # opzealot
        if self.merge:
            code_dict = {}
            for new_code, code_lst in self.merge_dict.items():
                for code in code_lst:
                    code_dict[code] = new_code
        # opzealot end

        with open(self.test_json_file, 'r', encoding='utf-8') as f:
            load_dict = json.load(f)
        images = load_dict['images']
        true_categories = []
        for image in images:
            image_name = image['file_name']
            true_category = image_name.split('/')[0]
            # opzealot
            if self.merge and true_category in code_dict:
                true_category = code_dict[true_category]
            # opzealot end
            true_categories.append(true_category)
        return true_categories

    def get_pred_img_category(self, rule_method='MaxConf_Prior', code_prior_list=None,
                              alpha=0.8, thr_ok=0.05, thr_others=0.6):
        """
        get the predict category for each image, we have many choice to decide
        """
        with open(self.test_pkl_file, 'rb') as f:
            results = pickle.load(f)

        from inferring.code_rule import CodeRule
        code_rule = CodeRule(rule_method, code_prior_list, alpha, thr_ok, thr_others,
                             model_categories=self.model_categories)

        prediction_categories = []
        for result in results:  # each result is corresponding with an image
            cate, _, _ = code_rule.get_main_code(result)
            if cate is None:
                cate = ok_code
            prediction_categories.append(cate)

        return prediction_categories

    def get_bounding_boxes(self):
        """
        get the predict bounding box for each image
        """
        with open(self.test_pkl_file, 'rb') as f:
            results = pickle.load(f)

        bounding_boxes_of_images = []
        for result in results:
            bounding_boxes_of_image = []
            for arr, category in zip(result, self.model_categories):
                for bbox in arr:
                    bounding_box_info = list(bbox)
                    bounding_box_info.append(category)
                    bounding_boxes_of_image.append(bounding_box_info)

                # if arr.size > 0:
                #     bounding_box = list(arr[0])  # get the bbox with maximum confidence
                #     bounding_box.append(category)
                #     bounding_boxes_of_image.append(bounding_box)
            bounding_boxes_of_images.append(bounding_boxes_of_image)

        return bounding_boxes_of_images

    def __draw_true_bounding_boxes(self, img, true_bounding_boxes, bbox_category_ids):
        """
        draw the true bounding boxes on the image
        """

        for true_bounding_box, bbox_category, i in zip(true_bounding_boxes,
                                                       bbox_category_ids, range(len(true_bounding_boxes))):
            xmin = true_bounding_box[0]
            ymin = true_bounding_box[1]
            xmax = xmin + true_bounding_box[2]
            ymax = ymin + true_bounding_box[3]
            bbox_category_name = self.model_categories[bbox_category - 1]

            cv2.rectangle(img, (int(xmin), int(ymin)), (int(xmax), int(ymax)), (0, 0, 255), thickness=3)

            if int(ymin) > 20:
                cv2.putText(img, bbox_category_name, (int(xmin - 40), int(ymin - 6 - 20 * i)),
                            cv2.FONT_HERSHEY_COMPLEX_SMALL, 3, (0, 0, 255))
            else:
                cv2.putText(img, bbox_category_name, (int(xmin - 40), int(ymax + 15 + 20 * i)),
                            cv2.FONT_HERSHEY_COMPLEX_SMALL, 3, (0, 0, 255))
        return img

    @staticmethod
    def __draw_pred_bounding_boxes(img, bounding_boxes_of_image, confidence_threshold):
        """
        draw the predict bounding box on the image
        :param img: img read by cv2.imread()
        :param bounding_boxes_of_image:
        :param confidence_threshold: only draw b-box with conf >= threshold
        :return:
        """
        confidences = []
        for bounding_box_of_image, i in zip(bounding_boxes_of_image, range(len(bounding_boxes_of_image))):
            xmin = bounding_box_of_image[0]
            ymin = bounding_box_of_image[1]
            xmax = bounding_box_of_image[2]
            ymax = bounding_box_of_image[3]
            confidence = bounding_box_of_image[4]
            bbox_category = bounding_box_of_image[5]
            confidences.append(confidence)

            if confidence > confidence_threshold:
                cv2.rectangle(img, (int(xmin), int(ymin)), (int(xmax), int(ymax)), (0, 255, 0), thickness=3)
                if False:  # int(ymin) > 20
                    cv2.putText(img, bbox_category + '{:.3f}'.format(confidence), (int(xmin - 40), int(ymin - 6 - 20 * i)),
                                cv2.FONT_HERSHEY_COMPLEX_SMALL, 3, (0, 0, 0))
                    # cv2.putText(img, '{:.3f}'.format(confidence), (int(xmax), int(ymin - 6 - 20 * i)),
                    #             cv2.FONT_HERSHEY_COMPLEX_SMALL, 3, (0, 0, 0))
                else:
                    cv2.putText(img, bbox_category + '{:.3f}'.format(confidence), (int(xmin - 40), int(ymax + 15 + 20 * i)),
                                cv2.FONT_HERSHEY_COMPLEX_SMALL, 3, (0, 0, 0))
                    # cv2.putText(img, '{:.3f}'.format(confidence), (int(xmax), int(ymax + 15 + 20 * i)),
                    #             cv2.FONT_HERSHEY_COMPLEX_SMALL, 3, (0, 0, 0))
        return img, confidences

    @staticmethod
    def __only_put_text_with_max_conf(img, bounding_boxes_of_image, confidences):
        """

        :param img:
        :param bounding_boxes_of_image:
        :param confidences: get from __draw_pred_bounding_boxes()
        :return:
        """

        for bounding_box_of_image in bounding_boxes_of_image:
            if bounding_box_of_image[4] == max(confidences):
                xmin = bounding_box_of_image[0]
                ymin = bounding_box_of_image[1]
                xmax = bounding_box_of_image[2]
                ymax = bounding_box_of_image[3]
                confidence = bounding_box_of_image[4]
                bbox_category = bounding_box_of_image[5]

                if int(ymin) > 20:
                    cv2.putText(img, bbox_category, (int(xmin - 40), int(ymin - 6)),
                                cv2.FONT_HERSHEY_COMPLEX_SMALL, 3, (0, 255, 0))
                    cv2.putText(img, '{:.3f}'.format(confidence), (int(xmax), int(ymin - 6)),
                                cv2.FONT_HERSHEY_COMPLEX_SMALL, 3, (0, 255, 0))
                else:
                    cv2.putText(img, bbox_category + " : .3f".format(confidence), (int(xmin - 40), int(ymax + 15)),
                                cv2.FONT_HERSHEY_COMPLEX_SMALL, 3, (0, 255, 0))
                    # cv2.putText(img, '{:.3f}'.format(confidence), (int(xmax), int(ymax + 15)),
                    #             cv2.FONT_HERSHEY_COMPLEX_SMALL, 3, (0, 255, 0))
        return img

    def draw_bounding_boxes(self, b_box_img_save_root, conf_threshold,
                            rule_method='MaxConf_Prior', code_prior_list=None,
                            alpha=0.8, thr_ok=0.05, thr_others=0.6):
        """
        output the b-box for each image, the true bbox and predict bbox are marked on the image

        :param b_box_img_save_root:
        :param conf_threshold:
        :param rule_method:
        :param code_prior_list:
        :param alpha:
        :param thr_ok:
        :param thr_others:
        :return:
        """

        bounding_boxes = self.get_bounding_boxes()
        true_categories = self.get_true_img_category()
        prediction_categories = self.get_pred_img_category(rule_method, code_prior_list, alpha, thr_ok, thr_others)

        with open(self.test_json_file, 'r', encoding='utf-8') as f:
            load_dict = json.load(f)
        images = load_dict['images']
        annotations = load_dict['annotations']

        for bounding_boxes_of_image, image, true_category, prediction_category in zip(
                bounding_boxes, images, true_categories, prediction_categories):
            # for each image
            image_name = image['file_name']
            file_name = image_name.split('/')[-1]
            image_id = image['id']
            true_bounding_boxes = []
            bbox_categories = []  # ids

            for annotation in annotations:
                if annotation['image_id'] == image_id:
                    true_bounding_boxes.append(annotation['bbox'])
                    bbox_categories.append(annotation['category_id'])

            img = cv2.imread(os.path.join(self.img_root, image_name))

            # true bounding box
            img = self.__draw_true_bounding_boxes(img, true_bounding_boxes, bbox_categories)

            # predict bounding box
            img, confidences = self.__draw_pred_bounding_boxes(img, bounding_boxes_of_image, conf_threshold)

            # If the maximum predict confidence is smaller than confidence_threshold, we output the maximum conf.
            if (len(confidences) > 0) and (max(confidences) < conf_threshold):
                img = self.__only_put_text_with_max_conf(img, bounding_boxes_of_image, confidences)

            if not os.path.exists(os.path.join(b_box_img_save_root, str(true_category), str(prediction_category))):
                os.makedirs(os.path.join(b_box_img_save_root, str(true_category), str(prediction_category)))

            cv2.imwrite(os.path.join(b_box_img_save_root, str(true_category), str(prediction_category), file_name), img)

    def get_confusion_matrix(self, rule_method='MaxConf_Prior', code_prior_list=None,
                             alpha=0.8, thr_ok=0.05, thr_others=0.6):
        true_categories = self.get_true_img_category()
        prediction_categories = self.get_pred_img_category(rule_method, code_prior_list, alpha, thr_ok, thr_others)

        matrix = confusion_matrix(true_categories, prediction_categories, labels=self.model_categories,
                                  sample_weight=None)
        return matrix

    @staticmethod
    def cm2df(conf_matrix, labels):
        df = pd.DataFrame()
        # rows
        for i, row_label in enumerate(labels):
            rowdata = {}
            # columns
            for j, col_label in enumerate(labels):
                rowdata[col_label] = conf_matrix[i, j]
            df = df.append(pd.DataFrame.from_dict({row_label: rowdata}, orient='index'))
        return df[labels]

    def save_confusion_matrix(self, save_file, rule_method='MaxConf_Prior', code_prior_list=None,
                              alpha=0.8, thr_ok=0.05, thr_others=0.6):
        """

        :param save_file:
        :param rule_method:
        :param code_prior_list:
        :param alpha:
        :param thr_ok:
        :param thr_others:
        :return:
        """

        conf_matrix = self.get_confusion_matrix(rule_method, code_prior_list, alpha, thr_ok, thr_others)
        save_path, file_name = os.path.split(save_file)
        if not os.path.exists(save_path):
            os.makedirs(save_path)
        cm_df = self.cm2df(conf_matrix, self.model_categories)

        precision_list = []
        recall_list = []
        for i in range(len(cm_df.columns)):
            precision_list.append(cm_df.iloc[i, i] / sum(cm_df[cm_df.columns[i]]))
            recall_list.append(cm_df.iloc[i, i] / sum(cm_df.loc[cm_df.columns[i]]))

        cm_df['recall'] = recall_list
        precision_list.append(None)
        cm_df.loc['precision'] = precision_list

        print(cm_df)

        cm_df.to_csv(save_file)


if __name__ == '__main__':

    img_root_ = '/home/scj/mm_detection_proj/stations/visionox_v3/samples'
    test_json_path_ = '/home/scj/mm_detection_proj/stations/visionox_v3/samples/test.json'
    test_pkl_path_ = '/home/scj/mm_detection_proj/stations/visionox_v3/work_dir/out_dir/epoch_2_2.pkl'

    analysis = ResultAnalysis(img_root_, test_json_path_, test_pkl_path_)
    analysis.save_confusion_matrix('/home/scj/mm_detection_proj/stations/visionox_v3/test_results/epoch_2_2_cm.csv',
                                   rule_method='MaxConf', alpha=0.7)

    # analysis = ResultAnalysis(img_root_, test_json_path_, test_pkl_path_)
    # analysis.save_confusion_matrix('/home/scj/mm_detection_proj/stations/visionox_v3/test_results/epoch_24_cm.csv',
    #                                rule_method='MaxConf', alpha=0.7)
#
#     analysis.draw_bounding_boxes('/home/scj/mm_detection_proj/stations/visionox_v3/test_results/epoch_24/', 0.3,
#                                  rule_method='MaxConf', alpha=0.7)

