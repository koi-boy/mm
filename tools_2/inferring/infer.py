#!/usr/bin/env python
# encoding:utf-8
"""
@author: sunchongjing
@license: (C) Copyright 2019, Union Big Data Co. Ltd. All rights reserved.
@contact: sunchongjing@unionbigdata.com
@software:
@file: infer.py
@time: 2019/9/6 16:23
@desc:
"""

import mmcv
import torch
from mmdet.apis import init_dist

from mmdet.apis import inference_detector, init_detector
from mmcv.runner import load_checkpoint
from inferring.code_rule import CodeRule

import os
import pandas as pd
from progressbar import ProgressBar
import time
import cv2
from utils import file_name_ext
from utils import image_draw


class ModelInfer(object):

    def __init__(self, config, checkpoint, categories, code_rule, device='cuda:0'):
        """

        :param config: test config file path, can use the training config file
        :param checkpoint: checkpoint file, generated by training process
        :param categories: the different category list, suggest load from test.json
        :param device:
        """
        assert isinstance(code_rule, CodeRule), 'the code_rule should be the type of CodeRule'

        self.config = config

        self.model = init_detector(config, checkpoint, device=device)
        self.checkpoint = load_checkpoint(self.model, checkpoint, map_location='cpu')

        self.model.CLASSES = categories
        self.code_rule = code_rule

    def predict(self, img):
        """

        :param img: the path of an image
        :return:
        """

        result = inference_detector(self.model, img)
        # cate, conf, bbox = self.code_rule.get_main_code(result)

        return result

    def get_main_code(self, result):
        cate, conf, bbox = self.code_rule.get_main_code(result)
        return cate, conf, bbox

    def get_bounding_boxes(self, result):

        bounding_boxes_of_image = []
        for arr, category in zip(result, self.model.CLASSES):
            for bbox in arr:
                bounding_box_info = list(bbox)
                bounding_box_info.append(category)
                bounding_boxes_of_image.append(bounding_box_info)

        return bounding_boxes_of_image

    @staticmethod
    def __only_put_text_with_max_conf(img, bounding_boxes_of_image, confidences):
        """

        :param img:
        :param bounding_boxes_of_image:
        :param confidences: get from __draw_pred_bounding_boxes()
        :return:
        """

        for bounding_box_of_image in bounding_boxes_of_image:
            if bounding_box_of_image[4] == max(confidences):

                confidence = bounding_box_of_image[4]
                bbox_category = bounding_box_of_image[5]

                image_draw.draw_bbox_with_code_conf(img, bbox_category, confidence, bounding_box_of_image[0:4])

        return img

    @staticmethod
    def __draw_pred_bounding_boxes(img, bounding_boxes_of_image, confidence_threshold):
        """
        draw the predict bounding box on the image
        :param img: img read by cv2.imread()
        :param bounding_boxes_of_image:
        :param confidence_threshold: only draw b-box with conf >= threshold
        :return:
        """
        confidences = []
        for bounding_box_of_image, i in zip(bounding_boxes_of_image, range(len(bounding_boxes_of_image))):

            confidence = bounding_box_of_image[4]
            bbox_category = bounding_box_of_image[5]
            confidences.append(confidence)

            if confidence > confidence_threshold:
                img = image_draw.draw_bbox_with_code_conf(img, bbox_category, confidence, bounding_box_of_image[0:4])

        return img, confidences

    def get_main_code_dir(self, img_dir, save_file):
        """
        only get the main code for each image in the dir, and save the results to file
        :param img_dir: the image directory
        :param save_file: csv file
        :return:
        """

        results = []
        pbar = ProgressBar().start()

        count = 0
        for img in os.listdir(img_dir):

            if not file_name_ext.is_supported_img_ext(img):
                count += 1
                continue

            pbar.update(int(count / (len(os.listdir(img_dir)) - 1) * 100))

            img_path = os.path.join(img_dir, img)
            result = self.predict(img_path)
            cate, conf, bbox = self.get_main_code(result)
            results.append({'img': img_path, 'code': cate, 'conf': conf, 'bbox': bbox})
            count += 1

        pbar.finish()
        result_df = pd.DataFrame(results)
        result_df.to_csv(save_file, index=False)

    def draw_bbox_dir(self, img_dir, save_dir, conf_threshold):
        """
        only draw the bbox for each image in the dir, and save the results to save dir

        :return:
        """
        pbar = ProgressBar().start()
        count = 0
        for img_name in os.listdir(img_dir):
            print(img_name)

            if not file_name_ext.is_supported_img_ext(img_name):
                count += 1
                continue

            print(int(count / (len(os.listdir(img_dir)) - 1) * 100))
            pbar.update(int(count / (len(os.listdir(img_dir)) - 1) * 100))

            img_path = os.path.join(img_dir, img_name)
            result = self.predict(img_path)
            bounding_boxes_of_image = self.get_bounding_boxes(result)
            img = cv2.imread(img_path)
            img, confidences = self.__draw_pred_bounding_boxes(img, bounding_boxes_of_image, conf_threshold)

            # If the maximum predict confidence is smaller than confidence_threshold, we output the maximum conf.
            if (len(confidences) > 0) and (max(confidences) < conf_threshold):
                img = self.__only_put_text_with_max_conf(img, bounding_boxes_of_image, confidences)

            if not os.path.exists(save_dir):
                os.makedirs(save_dir)

            cv2.imwrite(os.path.join(save_dir, img_name), img)
            count += 1

        pbar.finish()

    def get_main_code_draw_bbox_dir(self, img_dir, save_dir, img_conf_thr, result_save_csv):
        """
        get the main code for each image, save result to csv file, and draw the predict bbox for each imge
        :param img_dir:
        :param save_dir:
        :param img_conf_thr: the confidence threshold of bbox for drawing, the bbox with confidence less than
                                threshold will ignored
        :param result_save_csv:
        :return:
        """
        pbar = ProgressBar().start()

        results = []
        for i, img_name in enumerate(os.listdir(img_dir)):

            if not file_name_ext.is_supported_img_ext(img_name):
                continue

            pbar.update(int(i / (len(os.listdir(img_dir)) - 1) * 100))

            img_path = os.path.join(img_dir, img_name)
            result = self.predict(img_path)
            cate, conf, bbox = self.get_main_code(result)
            results.append({'img': img_path, 'code': cate, 'conf': conf, 'bbox': bbox})

            bounding_boxes_of_image = self.get_bounding_boxes(result)
            img = cv2.imread(img_path)
            img, confidences = self.__draw_pred_bounding_boxes(img, bounding_boxes_of_image, img_conf_thr)

            # If the maximum predict confidence is smaller than confidence_threshold, we output the maximum conf.
            if (len(confidences) > 0) and (max(confidences) < img_conf_thr):
                img = self.__only_put_text_with_max_conf(img, bounding_boxes_of_image, confidences)

            save_sub_dir = os.path.join(save_dir, cate)
            if not os.path.exists(save_sub_dir):
                os.makedirs(save_sub_dir)

            cv2.imwrite(os.path.join(save_sub_dir, img_name), img)

        pbar.finish()
        result_df = pd.DataFrame(results)
        result_df.to_csv(result_save_csv, index=False)


if __name__ == '__main__':

    model_categories = CodeRule.load_model_categories_from_coco_json('/home/adc_work_dir/OLED_1/test.json')
    code_rule = CodeRule(code_prior_list=['C5DH', 'C5HL', 'C5TF', 'Others'], model_categories=model_categories)

    config_file = '/home/adc_work_dir/work_dir_20190926/20190929_075416.py'
    checkpoint = '/home/adc_work_dir/work_dir_20190926/epoch_12.pth'
    model_infer = ModelInfer(config_file, checkpoint, model_categories, code_rule)

    img_dir = '/home/adc_work_dir/OLED_1/C5DH'
    save_dir = '/home/adc_work_dir/test_dir'
    result_csv = '/home/adc_work_dir/OLED_1/test.csv'
    model_infer.get_main_code_draw_bbox_dir(img_dir, save_dir, img_conf_thr=0.3, result_save_csv=result_csv)


